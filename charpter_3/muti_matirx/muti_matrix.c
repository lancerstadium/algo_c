/**
 * Muti Matrix 矩阵连乘问题
 * 问题描述：求矩阵连乘的最优解，要求以最小的代价（乘法次数最少）将它们相乘的问题。
 * 备注：矩阵相乘的顺序可以影响到乘法的代价，因为矩阵相乘不满足交换律，
 *      即矩阵A和B的乘积与B和A的乘积不一定相等。
 *      因此，不同的矩阵相乘顺序可能会导致不同的乘法次数，从而影响到乘法的代价。
 *      例如，假设我们有三个矩阵`A、B、C`，它们的维度分别是`10×30、30×5、5×60`。
 *      如果我们按照`(A*B)*C`的顺序相乘，
 *      那么乘法的次数为`10*30*5 + 10*5*60 = 1500 + 3000 = 4500`。
 *      但是，如果我们按照A*(B*C)的顺序相乘，
 *      那么乘法的次数为`30*5*60 + 10*30*60 = 9000 + 18000 = 27000`。
 *      可以看到，不同的相乘顺序导致了不同的乘法次数，从而影响到乘法的代价。
 * 算法思想：
 * 时间复杂度：
 * 空间复杂度：
 * 操作系统：Windows 11
 * 编译器：GCC 11.2.0
 * C标准：C11
 * 编译指令：gcc --std=c11 
 * 运行指令：
*/

#include <stdio.h>
#include <limits.h>

// 矩阵连乘问题的动态规划解决方案
int matrixChainOrder(int p[], int n) {
    // 1. 初始化数组：m[i][j]表示从第i个矩阵到第j个矩阵的最优乘法次数
    int m[n][n];
    int i, j, k, L, q;

    // 2. 初始化第一行：m[i][i] = 0，表示从第i个矩阵到第i个矩阵的最优乘法次数为0
    for (i = 1; i < n; i++) {
        m[i][i] = 0;
    }

    // 3. 递推公式：m[i][j] = min(m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j])
    for (L = 2; L < n; L++) {
        for (i = 1; i < n - L + 1; i++) {
            j = i + L - 1;     
            m[i][j] = INT_MAX;              // 初始化为最大值
            for (k = i; k <= j - 1; k++) {  // 寻找最优分割点
                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];     // 计算当前分割点
                if (q < m[i][j]) {
                    m[i][j] = q;
                }
            }
        }
    }

    // 4. 返回最优乘法次数：m[1][n - 1]
    return m[1][n - 1];
}

int main() {
    // 如果有n个矩阵A1, A2, …, An，它们的维度分别是d0×d1, d1×d2, …, dn-1×dn
    // 那么这些矩阵相乘的顺序可以影响到乘法的代价
    int arr[] = {10, 30, 5, 60};
    int size = sizeof(arr) / sizeof(arr[0]);

    printf("最小乘法次数为: %d\n", matrixChainOrder(arr, size));

    return 0;
}


