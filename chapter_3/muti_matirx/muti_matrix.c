/**
 * Muti Matrix 矩阵连乘问题
 * 问题描述：求矩阵连乘的最优解，要求以最小的代价（乘法次数最少）将它们相乘的问题。
 * 备注：矩阵相乘的顺序可以影响到乘法的代价，因为矩阵相乘不满足交换律，
 *      即矩阵A和B的乘积与B和A的乘积不一定相等。
 *      因此，不同的矩阵相乘顺序可能会导致不同的乘法次数，从而影响到乘法的代价。
 *      例如，假设我们有三个矩阵`A、B、C`，它们的维度分别是`10×30、30×5、5×60`。
 *      如果我们按照`(A*B)*C`的顺序相乘，
 *      那么乘法的次数为`10*30*5 + 10*5*60 = 1500 + 3000 = 4500`。
 *      但是，如果我们按照A*(B*C)的顺序相乘，
 *      那么乘法的次数为`30*5*60 + 10*30*60 = 9000 + 18000 = 27000`。
 *      可以看到，不同的相乘顺序导致了不同的乘法次数，从而影响到乘法的代价。
 * 算法思想：动态规划解决矩阵连乘问题的算法思想如下：
 *      1. 定义状态：首先需要定义一个二维数组dp[i][j]，其中dp[i][j]表示从第i个矩阵到第j个矩阵相乘所需的最小乘法次数。
 *          状态转移方程：对于任意的i <= k < j，假设我们选择第k个矩阵作为划分点，则有：
 *              dp[i][j] = min(dp[i][k] + dp[k+1][j] + r[i-1]*r[k]*r[j])
 *              其中r[i]表示第i个矩阵的行数，r[i-1]表示第i个矩阵的列数。
 *      2. 初始化：对于单个矩阵而言，它与自身相乘的次数为0，因此dp[i][i] = 0。
 *      3. 填表求解：根据状态转移方程，从状态数组的初始状态开始，依次填表求解dp[i][j]的值，直到填满整个状态数组。
 *      4. 最优解：最终的最优解即为dp[1][n]，其中n表示矩阵的个数。
 * 时间复杂度：
 * 空间复杂度：
 * 操作系统：Windows 11
 * 编译器：GCC 11.2.0
 * C标准：C11
 * 编译指令：gcc --std=c11 muti_matrix.c -o muti_matrix
 * 运行指令：.\muti_matrix.exe
*/

#include <stdio.h>

// 定义矩阵的数量
#define N 6

// 矩阵的行数和列数
int r[N+1] = {10, 30, 5, 60, 10, 20, 25};

// 定义动态规划数组
int dp[N+1][N+1];

// 返回a和b的最小值
int min(int a, int b) {
    return a < b ? a : b;
}

// 动态规划求解矩阵连乘问题
int matrixChainOrder() {
    // 1. 初始化边界条件
    for (int i = 1; i <= N; i++) {
        dp[i][i] = 0;
    }

    // 2. 填表求解
    for (int l = 2; l <= N; l++) {
        for (int i = 1; i <= N - l + 1; i++) {
            int j = i + l - 1;
            dp[i][j] = 99999999; // 初始值设为一个较大的数
            for (int k = i; k <= j - 1; k++) {
                int q = dp[i][k] + dp[k+1][j] + r[i-1]*r[k]*r[j];
                dp[i][j] = min(dp[i][j], q);
            }
        }
    }

    // 3. 返回最优解
    return dp[1][N];
}

int main() {
    int result = matrixChainOrder();
    // 打印矩阵维度信息
    for (int i = 1; i <= N; i++) {
        printf("%d ", r[i]);
    }
    printf("\nMinimum number of multiplications is: %d\n", result);

    return 0;
}



